
master:

  config: |-
    # Enter any extra configuration for master.toml here.
    # It may be a multi-line string.

  # You may use ANY storage-class, example with local-path-provisioner
  # Annotations are optional.
  #  data:
  #    type: "persistentVolumeClaim"
  #    size: "24Ti"
  #    storageClass: "local-path-provisioner"
  #    annotations:
  #      "key": "value"
  

  data:
    type: "persistentVolumeClaim"
    size: "20Gi"
    storageClass: "longhorn"
  
  # You may use ANY storage-class, example with local-path-provisioner
  # Annotations are optional.
  # logs:
  #   type: "persistentVolumeClaim"
  #   size: "24Ti"
  #   storageClass: "local-path-provisioner"
  #   annotations:
  #     "key": "value"

  # You can also use emptyDir storage:
  #  logs:
  #    type: "emptyDir"
  logs:
    type: "persistentVolumeClaim"
    size: "10Gi"
    storageClass: "longhorn"

  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: master
          topologyKey: kubernetes.io/hostname

  
  ingress:
    enabled: true
    className: "traefik"
    # host: false for "*" hostname
    host: "master-sw.philippmhauptmann.me"
    path: "/sw-master/?(.*)"
    pathType: ImplementationSpecific
    annotations:
      traefik.ingress.kubernetes.io/router.tls.certresolver: cloudflare

filer:
  
  data:
    type: "persistentVolumeClaim"
    size: "20Gi"
    storageClass: "longhorn"

  # You may use ANY storage-class, example with local-path-provisioner
  # Annotations are optional.
  # logs:
  #   type: "persistentVolumeClaim"
  #   size: "24Ti"
  #   storageClass: "local-path-provisioner"
  #   annotations:
  #     "key": "value"

  # You can also use emptyDir storage:
  #  logs:
  #    type: "emptyDir"
  logs:
    type: "persistentVolumeClaim"
    size: "10Gi"
    storageClass: "longhorn"

  
  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: filer
          topologyKey: kubernetes.io/hostname

  
  ingress:
    enabled: false
    className: "nginx"
    # host: false for "*" hostname
    host: "seaweedfs.cluster.local"
    path: "/sw-filer/?(.*)"
    pathType: ImplementationSpecific
    annotations:
      traefik.ingress.kubernetes.io/router.tls.certresolver: cloudflare


  s3:
    enabled: true
    port: 8333
    # add additional https port
    httpsPort: 443
    # allow empty folders
    allowEmptyFolder: false
    # Suffix of the host name, {bucket}.{domainName}
    domainName: ""
    # enable user & permission to s3 (need to inject to all services)
    enableAuth: false
    # set to the name of an existing kubernetes Secret with the s3 json config file
    # should have a secret key called seaweedfs_s3_config with an inline json configure
    existingConfigSecret: null
    auditLogConfig: {}
    # You may specify buckets to be created during the install process.
    # Buckets may be exposed publicly by setting `anonymousRead` to `true`
    # createBuckets:
    #   - name: bucket-a
    #     anonymousRead: true
    #   - name: bucket-b
    #     anonymousRead: false

volume:
  enabled: true
  imageOverride: null
  restartPolicy: null
  port: 8080
  grpcPort: 18080
  metricsPort: 9327
  metricsIp: ""  # Metrics listen IP. If empty, defaults to ipBind
  ipBind: "0.0.0.0"
  replicas: 1
  loggingOverrideLevel: null
  # number of seconds between heartbeats, must be smaller than or equal to the master's setting
 
  dataDirs:
  - name: data1
    type: "persistentVolumeClaim"
    size: "100Gi"
    storageClass: "longhorn"


   # - name: data2
   #   type: "persistentVolumeClaim"
   #   storageClass: "yourClassNameOfChoice"
   #   size: "800Gi"
   #   maxVolumes: 0

  # This will automatically create a job for patching Kubernetes resources if the dataDirs type is 'persistentVolumeClaim' and the size has changed.
  resizeHook:
    enabled: true
    image: alpine/k8s:1.28.4

  idx:
   type: "persistentVolumeClaim"
   size: "20Gi"
   storageClass: "longhorn"

  logs:
   type: "persistentVolumeClaim"
   size: "10Gi"
   storageClass: "longhorn"


s3:
  enabled: false
  
  # enable user & permission to s3 (need to inject to all services)
  enableAuth: false
  # set to the name of an existing kubernetes Secret with the s3 json config file
  # should have a secret key called seaweedfs_s3_config with an inline json config
  existingConfigSecret: null
  auditLogConfig: {}

  # Suffix of the host name, {bucket}.{domainName}
  domainName: ""

  logs:
    type: "persistentVolumeClaim"
    size: "10Gi"
    storageClass: "longhorn"
  extraEnvironmentVars:



  ingress:
    enabled: false
    className: "nginx"
    # host: false for "*" hostname
    host: "seaweedfs.cluster.local"
    path: "/"
    pathType: Prefix
    # additional ingress annotations for the s3 endpoint
    annotations: {}
    tls: []
