
master:

  config: |-
    # Enter any extra configuration for master.toml here.
    # It may be a multi-line string.

  # You may use ANY storage-class, example with local-path-provisioner
  # Annotations are optional.
  #  data:
  #    type: "persistentVolumeClaim"
  #    size: "24Ti"
  #    storageClass: "local-path-provisioner"
  #    annotations:
  #      "key": "value"
  
  data:
    type: "hostPath"
    storageClass: "longhorn"
    hostPathPrefix: /ssd

  # You may use ANY storage-class, example with local-path-provisioner
  # Annotations are optional.
  # logs:
  #   type: "persistentVolumeClaim"
  #   size: "24Ti"
  #   storageClass: "local-path-provisioner"
  #   annotations:
  #     "key": "value"

  # You can also use emptyDir storage:
  #  logs:
  #    type: "emptyDir"
  logs:
    type: "hostPath"
    size: ""
    storageClass: "longhorn"
    hostPathPrefix: /storage

  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: master
          topologyKey: kubernetes.io/hostname

  
  ingress:
    enabled: true
    className: "traefik"
    # host: false for "*" hostname
    host: "master-sw.philippmhauptmann.me"
    path: "/sw-master/?(.*)"
    pathType: ImplementationSpecific
    annotations:
      traefik.ingress.kubernetes.io/router.tls.certresolver: cloudflare

filer:
  
  data:
    type: "hostPath"
    size: ""
    storageClass: "longhorn"
    hostPathPrefix: /storage

  # You may use ANY storage-class, example with local-path-provisioner
  # Annotations are optional.
  # logs:
  #   type: "persistentVolumeClaim"
  #   size: "24Ti"
  #   storageClass: "local-path-provisioner"
  #   annotations:
  #     "key": "value"

  # You can also use emptyDir storage:
  #  logs:
  #    type: "emptyDir"
  logs:
    type: "hostPath"
    size: ""
    storageClass: "longhorn"
    hostPathPrefix: /storage

  
  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: filer
          topologyKey: kubernetes.io/hostname

  
  ingress:
    enabled: false
    className: "nginx"
    # host: false for "*" hostname
    host: "seaweedfs.cluster.local"
    path: "/sw-filer/?(.*)"
    pathType: ImplementationSpecific
    annotations:
      traefik.ingress.kubernetes.io/router.tls.certresolver: cloudflare


  s3:
    enabled: true
    port: 8333
    # add additional https port
    httpsPort: 443
    # allow empty folders
    allowEmptyFolder: false
    # Suffix of the host name, {bucket}.{domainName}
    domainName: ""
    # enable user & permission to s3 (need to inject to all services)
    enableAuth: false
    # set to the name of an existing kubernetes Secret with the s3 json config file
    # should have a secret key called seaweedfs_s3_config with an inline json configure
    existingConfigSecret: null
    auditLogConfig: {}
    # You may specify buckets to be created during the install process.
    # Buckets may be exposed publicly by setting `anonymousRead` to `true`
    # createBuckets:
    #   - name: bucket-a
    #     anonymousRead: true
    #   - name: bucket-b
    #     anonymousRead: false

s3:
  enabled: false
  imageOverride: null
  restartPolicy: null
  replicas: 1
  bindAddress: 0.0.0.0
  port: 8333
  # add additional https port
  httpsPort: 0
  metricsPort: 9327
  loggingOverrideLevel: null
  # allow empty folders
  allowEmptyFolder: true
  # enable user & permission to s3 (need to inject to all services)
  enableAuth: false
  # set to the name of an existing kubernetes Secret with the s3 json config file
  # should have a secret key called seaweedfs_s3_config with an inline json config
  existingConfigSecret: null
  auditLogConfig: {}

  # Suffix of the host name, {bucket}.{domainName}
  domainName: ""

  ## @param s3.sidecars Add additional sidecar containers to the s3 pod(s)
  ## e.g:
  ## sidecars:
  ##   - name: your-image-name
  ##     image: your-image
  ##     imagePullPolicy: Always
  ##     ports:
  ##       - name: portname
  ##         containerPort: 1234
  ##
  sidecars: []
  initContainers: ""

  extraVolumes: ""
  extraVolumeMounts: ""

  # Labels to be added to the s3 pods
  podLabels: {}

  # Annotations to be added to the s3 pods
  podAnnotations: {}

  # Annotations to be added to the s3 resources
  annotations: {}

  # Resource requests, limits, etc. for the server cluster placement. This
  # should map directly to the value of the resources field for a PodSpec,
  # formatted as a multi-line string. By default no direct resource request
  # is made.
  resources: {}

  # Toleration Settings for server pods
  # This should be a multi-line string matching the Toleration array
  # in a PodSpec.
  tolerations: ""

  # nodeSelector labels for server pod assignment, formatted as a muli-line string.
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # Example:
  nodeSelector: ""
  # nodeSelector: |
  #   sw-backend: "true"

  # used to assign priority to server pods
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: ""

  # used to assign a service account.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccountName: ""

  # Configure security context for Pod
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  # Example:
  # podSecurityContext:
  #   enabled: true
  #   runAsUser: 1000
  #   runAsGroup: 3000
  #   fsGroup: 2000
  podSecurityContext: {}

  # Configure security context for Container
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  # Example:
  # containerSecurityContext:
  #   enabled: true
  #   runAsUser: 2000
  #   allowPrivilegeEscalation: false
  containerSecurityContext: {}

  # You can also use emptyDir storage:
  #  logs:
  #    type: "emptyDir"
  logs:
    type: "hostPath"
    size: ""
    storageClass: ""
    hostPathPrefix: /storage

  extraEnvironmentVars:

  # Custom command line arguments to add to the s3 command
  # Example to fix connection idle seconds:
  extraArgs: ["-idleTimeout=30"]
  # extraArgs: []

  # used to configure livenessProbe on s3 containers
  #
  livenessProbe:
    enabled: true
    httpGet:
      path: /status
      scheme: HTTP
    initialDelaySeconds: 20
    periodSeconds: 60
    successThreshold: 1
    failureThreshold: 20
    timeoutSeconds: 10

  # used to configure readinessProbe on s3 containers
  #
  readinessProbe:
    enabled: true
    httpGet:
      path: /status
      scheme: HTTP
    initialDelaySeconds: 15
    periodSeconds: 15
    successThreshold: 1
    failureThreshold: 100
    timeoutSeconds: 10

  ingress:
    enabled: false
    className: "nginx"
    # host: false for "*" hostname
    host: "seaweedfs.cluster.local"
    path: "/"
    pathType: Prefix
    # additional ingress annotations for the s3 endpoint
    annotations: {}
    tls: []

sftp:
  enabled: false
  imageOverride: null
  restartPolicy: null
  replicas: 1
  bindAddress: 0.0.0.0
  port: 2022  # Default SFTP port
  metricsPort: 9327
  metricsIp: ""  # If empty, defaults to bindAddress
  loggingOverrideLevel: null

  # SSH server configuration
  sshPrivateKey: "/etc/sw/seaweedfs_sftp_ssh_private_key"  # Path to the SSH private key file for host authentication
  hostKeysFolder: "/etc/sw/ssh"  # path to folder containing SSH private key files for host authentication
  authMethods: "password,publickey"  # Comma-separated list of allowed auth methods: password, publickey, keyboard-interactive
  maxAuthTries: 6  # Maximum number of authentication attempts per connection
  bannerMessage: "SeaweedFS SFTP Server"  # Message displayed before authentication
  loginGraceTime: "2m"  # Timeout for authentication
  clientAliveInterval: "5s"  # Interval for sending keep-alive messages
  clientAliveCountMax: 3  # Maximum number of missed keep-alive messages before disconnecting
  dataCenter: ""  # Prefer to read and write to volumes in this data center
  localSocket: ""  # Default to /tmp/seaweedfs-sftp-<port>.sock

  # User authentication
  enableAuth: false
  # Set to the name of an existing kubernetes Secret with the sftp json config file
  # Should have a secret key called seaweedfs_sftp_config with an inline json config
  existingConfigSecret: null
  # Set to the name of an existing kubernetes Secret with the list of ssh private keys for sftp
  existingSshConfigSecret: null

  # Additional resources
  sidecars: []
  initContainers: ""
  extraVolumes: ""
  extraVolumeMounts: ""
  podLabels: {}
  podAnnotations: {}
  annotations: {}
  resources: {}
  tolerations: ""
  nodeSelector: ""
  priorityClassName: ""
  serviceAccountName: ""
  podSecurityContext: {}
  containerSecurityContext: {}

  logs:
    type: "hostPath"
    hostPathPrefix: /storage

  extraEnvironmentVars: {}

  # Health checks
  # Health checks for SFTP - using tcpSocket instead of httpGet
  livenessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 60
    successThreshold: 1
    failureThreshold: 20
    timeoutSeconds: 10

  # Health checks for SFTP - using tcpSocket instead of httpGet
  readinessProbe:
    enabled: true
    initialDelaySeconds: 15
    periodSeconds: 15
    successThreshold: 1
    failureThreshold: 100
    timeoutSeconds: 10

# All-in-one deployment configuration
allInOne:
  enabled: false
  imageOverride: null
  restartPolicy: Always

  # Core configuration
  idleTimeout: 30  # Connection idle seconds
  dataCenter: ""  # Current volume server's data center name
  rack: ""  # Current volume server's rack name
  whiteList: ""  # Comma separated IP addresses having write permission
  disableHttp: false  # Disable HTTP requests, only gRPC operations are allowed
  metricsPort: 9324  # Prometheus metrics listen port
  metricsIp: ""  # Metrics listen IP. If empty, defaults to bindAddress
  loggingOverrideLevel: null  # Override logging level

  # Service configuration
  s3:
    enabled: false  # Whether to enable S3 gateway
  sftp:
    enabled: false  # Whether to enable SFTP server

  # Service settings
  service:
    annotations: {}  # Annotations for the service
    type: ClusterIP  # Service type (ClusterIP, NodePort, LoadBalancer)

  # Storage configuration
  data:
    type: "emptyDir"  # Options: "hostPath", "persistentVolumeClaim", "emptyDir"
    hostPathPrefix: /mnt/data  # Path prefix for hostPath volumes
    claimName: seaweedfs-data-pvc  # Name of the PVC to use
    size: ""  # Size of the PVC
    storageClass: ""  # Storage class for the PVC

  # Health checks
  readinessProbe:
    enabled: true
    httpGet:
      path: /cluster/status
      port: 9333
    scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 15
    successThreshold: 1
    failureThreshold: 3
    timeoutSeconds: 5

  livenessProbe:
    enabled: true
    httpGet:
      path: /cluster/status
      port: 9333
    scheme: HTTP
    initialDelaySeconds: 20
    periodSeconds: 30
    successThreshold: 1
    failureThreshold: 5
    timeoutSeconds: 5

  # Additional resources
  extraEnvironmentVars: {}  # Additional environment variables
  extraVolumeMounts: ""  # Additional volume mounts
  extraVolumes: ""  # Additional volumes
  initContainers: ""  # Init containers
  sidecars: ""  # Sidecar containers
  annotations: {}  # Annotations for the deployment
  podAnnotations: {}  # Annotations for the pods
  podLabels: {}  # Labels for the pods

  # Scheduling configuration
  # Affinity Settings
  # Commenting out or setting as empty the affinity variable, will allow
  # deployment to single node services such as Minikube
  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/name: {{ template "seaweedfs.name" . }}
              app.kubernetes.io/instance: {{ .Release.Name }}
              app.kubernetes.io/component: master
          topologyKey: kubernetes.io/hostname

  # Topology Spread Constraints Settings
  # This should map directly to the value of the topologySpreadConstraints
  # for a PodSpec. By Default no constraints are set.
  topologySpreadConstraints: ""

  # Toleration Settings for master pods
  # This should be a multi-line string matching the Toleration array
  # in a PodSpec.
  tolerations: ""

  # nodeSelector labels for master pod assignment, formatted as a muli-line string.
  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  nodeSelector: ""

  # Used to assign priority to master pods
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  priorityClassName: ""

  # Used to assign a service account.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  serviceAccountName: ""

  # Configure security context for Pod
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  # Example:
  # podSecurityContext:
  #   enabled: true
  #   runAsUser: 1000
  #   runAsGroup: 3000
  #   fsGroup: 2000
  podSecurityContext: {}

  # Configure security context for Container
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  # Example:
  # containerSecurityContext:
  #   enabled: true
  #   runAsUser: 2000
  #   allowPrivilegeEscalation: false
  containerSecurityContext: {}

  # Resource management
  resources:
    limits:
      cpu: "2"
      memory: "2Gi"
    requests:
      cpu: "500m"
      memory: "1Gi"
